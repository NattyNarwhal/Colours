using System;
using System.Collections.Generic;
using System.Drawing;

namespace Colours
{
    /// <summary>
    /// Represents the minimum amount of application state.
    /// This is also used for undo/redo.
    /// </summary>
    [Serializable]
    public class AppState
    {
        public HsvColor Color { get; set; }
        public SchemeType SchemeType { get; set; }

        public AppState(HsvColor c, SchemeType t)
        {
            Color = c;
            SchemeType = t;
        }

        public override string ToString()
        {
            return String.Format("{0} of {1}", SchemeType.ToString(),
                ColorTranslator.ToHtml(Color.ToRgb()));
        }
    }

    /// <summary>
    /// Represents the backend of the application.
    /// </summary>
    public class AppController
    {
        /// <summary>
        /// The current color, in HSV form. Use
        /// <see cref="Colours.AppController.SetColor(Color, bool)"/>
        /// to change the color.
        /// </summary>
        public HsvColor HsvColor { get; private set; }
        /// <summary>
        /// The current color, in GDI form. Use
        /// <see cref="Colours.AppController.SetColor(HsvColor, bool)"/>
        /// to change the color.
        /// </summary>
        public Color Color { get; private set; }

        /// <summary>
        /// The current colour scheme. Use
        /// <see cref="Colours.AppController.SetSchemeType(Colours.SchemeType, bool)"/>
        /// to change the scheme.
        /// </summary>
        public SchemeType SchemeType { get; private set; }

        /// <summary>
        /// The undo history. This will be set for you by the functions in this object.
        /// </summary>
        public Stack<AppState> UndoHistory { get; private set; }
        /// <summary>
        /// The redo history. This will be set for you by the functions in this object.
        /// </summary>
        public Stack<AppState> RedoHistory { get; private set; }

        /// <summary>
        /// The current resulting colour scheme. This will be generated by
        /// <see cref="Colours.AppController.GetSchemeResults"/> whenever
        /// the colour or scheme is set.
        /// </summary>
        public List<HsvColor> Results { get; private set; }

        /// <summary>
        /// Creates a new application controller.
        /// </summary>
        /// <param name="c">The initial colour to use.</param>
        /// <param name="scheme">The initial scheme to use.</param>
        public AppController(HsvColor c, SchemeType scheme)
        {
            UndoHistory = new Stack<AppState>();
            RedoHistory = new Stack<AppState>();

            SchemeType = scheme;
            SetColor(c, false); // this will set Results
        }

        /// <summary>
        /// Pushes the current state of the application to the undo stack.
        /// </summary>
        private void PushUndo()
        {
            UndoHistory.Push(new AppState(HsvColor, SchemeType));
            RedoHistory.Clear();
        }

        /// <summary>
        /// Set the current scheme type and generate the Results in the
        /// Results property.
        /// </summary>
        /// <param name="t">The new scheme type.</param>
        /// <param name="keepHistory">
        /// If you want to update the undo stack. Note that it will only update it if
        /// the current scheme and new scheme are different.
        /// </param>
        public void SetSchemeType(SchemeType t, bool keepHistory)
        {
            if (keepHistory && SchemeType != t)
            {
                PushUndo();
            }
            SchemeType = t;
            GetSchemeResults();
        }

        /// <summary>
        /// Set the current colour (in HSV form) and generate the Results in the
        /// Results property.
        /// </summary>
        /// <param name="c">The new colour.</param>
        /// <param name="keepHistory">
        /// If you want to update the undo stack. Note that it will only update it if
        /// the current colour and new colour are different.
        /// </param>
        public void SetColor(HsvColor c, bool keepHistory)
        {
            if (keepHistory && c.ToString() != HsvColor.ToString())
            {
                PushUndo();
            }
            HsvColor = c;
            Color = c.ToRgb();
            GetSchemeResults();
        }

        /// <summary>
        /// Set the current colour (in GDI form) and generate the Results in the
        /// Results property.
        /// </summary>
        /// <param name="c">The new colour.</param>
        /// <param name="keepHistory">
        /// If you want to update the undo stack. Note that it will only update it if
        /// the current colour and new colour are different.
        /// </param>
        public void SetColor(Color c, bool keepHistory)
        {
            if (keepHistory && c.ToString() != Color.ToString())
            {
                PushUndo();
            }
            Color = c;
            HsvColor = new HsvColor(c);
            GetSchemeResults();
        }

        public void Brighten()
        {
            if (CanBrighten())
            {
                SetColor(new HsvColor(HsvColor.Hue,
                    HsvColor.Saturation, HsvColor.Value + 0.05d), true);
            }
        }

        public void Darken()
        {
            if (CanDarken())
            {
                SetColor(new HsvColor(HsvColor.Hue,
                    HsvColor.Saturation, HsvColor.Value - 0.05d), true);
            }
        }

        public void Saturate()
        {
            if (CanSaturate())
            {
                SetColor(new HsvColor(HsvColor.Hue,
                    HsvColor.Saturation + 0.05d, HsvColor.Value), true);
            }
        }

        public void Desaturate()
        {
            if (CanDesaturate())
            {
                SetColor(new HsvColor(HsvColor.Hue,
                    HsvColor.Saturation - 0.05d, HsvColor.Value), true);
            }
        }

        public bool CanBrighten()
        {
            return HsvColor.Value + 0.05d < 1d;
        }

        public bool CanDarken()
        {
            return HsvColor.Value - 0.05d > 0d;
        }

        public bool CanSaturate()
        {
            return HsvColor.Saturation + 0.05d < 1d;
        }

        public bool CanDesaturate()
        {
            return HsvColor.Saturation - 0.05d > 0d;
        }

        /// <summary>
        /// Get the results of the colour and scheme combination.
        /// This will be called by the varioous setters in the object.
        /// </summary>
        private void GetSchemeResults()
        {
            switch (SchemeType)
            {
                case SchemeType.Complement:
                    Results = ColorSchemer.Complement(HsvColor);
                    break;
                case SchemeType.SplitComplements:
                    Results = ColorSchemer.SplitComplement(HsvColor);
                    break;
                case SchemeType.Triads:
                    Results = ColorSchemer.Triads(HsvColor);
                    break;
                case SchemeType.Tetrads:
                    Results = ColorSchemer.Tetrads(HsvColor);
                    break;
                case SchemeType.Analogous:
                    Results = ColorSchemer.Analogous(HsvColor);
                    break;
                case SchemeType.Monochromatic:
                    Results = ColorSchemer.Monochromatic(HsvColor);
                    break;
                default:
                    throw new ArgumentOutOfRangeException("Not a valid type of scheme.");
            }
        }

        public void Undo()
        {
            if (CanUndo())
            {
                RedoHistory.Push(new AppState(HsvColor, SchemeType));
                AppState s = UndoHistory.Pop();
                SetColor(s.Color, false);
                SetSchemeType(s.SchemeType, false);
            }
        }

        public void Redo()
        {
            if (CanRedo())
            {
                UndoHistory.Push(new AppState(HsvColor, SchemeType));
                AppState s = RedoHistory.Pop();
                SetColor(s.Color, false);
                SetSchemeType(s.SchemeType, false);
            }
        }

        public bool CanUndo()
        {
            return UndoHistory.Count > 0;
        }

        public bool CanRedo()
        {
            return RedoHistory.Count > 0;
        }
    }
}
